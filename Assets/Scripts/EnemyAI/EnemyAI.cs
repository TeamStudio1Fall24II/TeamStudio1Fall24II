using System.Collections;
using System.Data.Common;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Events;

public class EnemyAI : MonoBehaviour, IDamageable
{
     public UnityAction<GameObject> DeathEvent;
     public UnityAction PlayerDetectEvent;

     [SerializeField]
     public EnemyDataSO Data;
     public EnemyAIBehavior CurrentBehavior;
     public Scan ScanBehavior;
     public Combat CombatBehavior;
     private NavMeshAgent navMeshAgent;

     private float FOVRaycastTimer = 0.0f;

     private GameObject Target;
     private bool isPlayerDetected = false;

     private int currentHealth;

     public enum State
     {
          Idle,
          Scan,
          Patrol,
          Investigate,
          Chase,
          Combat,
          Die
     }

     public State CurrentState;
     // Starts in this state and will return to this state if nothing else is going on.
     public State DefaultState;

     private void Awake()
     {
          Target = GameObject.Find("Player");

          navMeshAgent = GetComponent<NavMeshAgent>();

          ScanBehavior = new Scan(Data, navMeshAgent, gameObject);
          CombatBehavior = new Combat(Data, navMeshAgent, gameObject, Target);

          currentHealth = Data.m_HealthData.MaxHealth;
     }

     private void OnEnable()
     {
          CurrentState = DefaultState;
          switch (CurrentState)
          {
               case State.Idle:
                    // Do nothing
                    break;
               case State.Scan:
                    CurrentBehavior = ScanBehavior;
                    break;
               case State.Patrol:
                    break;
               case State.Investigate:
                    break;
               case State.Chase:
                    break;
               case State.Combat:
                    CurrentBehavior = CombatBehavior;
                    break;
               case State.Die:
                    break;
          }
     }

     // TODO: Eventually need to integrate animations
     // Update is called once per frame
     void Update()
    {
          // TODO: make this an actual behavior
          if(CurrentState == State.Die) 
          { 
               //DeathSequence();
               return;
          }

          CurrentBehavior?.Tick();
          FOVDetect();
    }

     private void TransitionToCombat()
     {
          CurrentState = State.Combat;
          CurrentBehavior = CombatBehavior;
     }

     private void TransitionToDeath()
     {
          CurrentState = State.Die;
          CurrentBehavior = null;
          StartCoroutine(DeathSequence());
     }

     // FOVDetect partially generated by Gemini AI
     private void FOVDetect()
     {
          FOVRaycastTimer += Time.deltaTime;
          if(FOVRaycastTimer < Data.m_FOVData.RaycastTime) { return; }
          FOVRaycastTimer = 0.0f;

          // Current assumption that there is only 1 target, if it is already acquired, no need to detect
          if(isPlayerDetected) { return; }

          Vector3 directionToTarget = (Target.transform.position - transform.position).normalized;
          float angleBetweenTargetAndForward = Vector3.Angle(transform.forward, directionToTarget);

          if (angleBetweenTargetAndForward < Data.m_FOVData.FieldOfViewAngle / 2)
          {
               RaycastHit hit;
               if (Physics.Raycast(transform.position, directionToTarget, out hit, Data.m_FOVData.ViewDistance))
               {
                    if (hit.collider.CompareTag("Player"))
                    {
                         isPlayerDetected = true;
                         PlayerDetectEvent?.Invoke();
                         TransitionToCombat();
                    }
               }
          }
     }

     public void TakeDamage(int damage)
     {
          if(CurrentState == (State.Die)) { return; }

          Debug.Log("I've been hit! " + damage + " Damage");
          currentHealth -= damage;
          if (currentHealth <= 0)
          {
               DeathEvent?.Invoke(gameObject);
               TransitionToDeath();
               return;
          }
          if(CurrentState != State.Combat)
          {
               TransitionToCombat();
          }

     }

     public float rotationAngle = 90f;
     private float rotationDuration = 2.0f; // Adjust duration as needed

     public IEnumerator DeathSequence()
     {
          // TODO: integrate animations. 
          navMeshAgent.enabled = false;
          float elapsedTime = 0f;
          Vector3 startPosition = transform.position;
          Vector3 targetPosition = transform.position - Vector3.up;
          Quaternion startRotation = transform.rotation;
          Quaternion targetRotation = transform.rotation * Quaternion.Euler(rotationAngle, transform.rotation.y, transform.rotation.z);

          while (elapsedTime < rotationDuration)
          {
               float timeStep = elapsedTime / rotationDuration;
               transform.rotation = Quaternion.Slerp(startRotation, targetRotation, timeStep);
               transform.position = Vector3.Lerp(startPosition, targetPosition, timeStep);
               elapsedTime += Time.deltaTime;
               yield return null;
          }

          transform.rotation = targetRotation;
          Destroy(gameObject, 2.0f);
     }
}



